options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(Jmm)
public class Jmm {
    public static void main(String args[]) throws ParseException {
        
        System.out.println("Write an Java-- expression:");
        Jmm myParser = new Jmm(System.in);
        SimpleNode root = myParser.Program(); // returns reference to root node
        
        root.dump(""); // prints the tree on the screen
        System.out.println("Finished Parsing");
        }
    }

PARSER_END(Jmm)


SKIP :
{
      " "
    | "\t"
    | "\r"
    | "\n"
}

/////////////////////////////////////////////////////////////////////////////
// From the JavaCC FAQ https://javacc.github.io/javacc/faq.html#question-3.14
/////////////////////////////////////////////////////////////////////////////

// when /* is seen in the DEFAULT state, skip it and switch to the IN_COMMENT state
MORE : {
  "/*": IN_COMMENT
  | "//": IN_SINGLE_LINE_COMMENT
}

// when any other character is seen in the IN_COMMENT state, skip it.
< IN_COMMENT > MORE : {
  < ~[] >
}

// when */ is seen in the IN_COMMENT state, skip it and switch back to the DEFAULT state
< IN_COMMENT > SKIP : {
  "*/": DEFAULT
}

< IN_SINGLE_LINE_COMMENT > SPECIAL_TOKEN : {
  < SINGLE_LINE_COMMENT: "\n"|"\r"|"\r\n" > : DEFAULT
}

< IN_SINGLE_LINE_COMMENT > MORE : {
  < ~[] >
}

TOKEN :
{

    <IntegerLiteral: ["1" - "9"] (<Digit>)*>
    | <Digit: ["0" - "9"] >

    | <OpenBlock: "{" >
    | <CloseBlock: "}" >
    | <OpenParenthesis: "(" >
    | <CloseParenthesis: ")" >
    | <OpenArray: "[" >
    | <CloseArray: "]" >
    | <Semicolon: ";" >
    | <Comma: "," >
    | <Equals: "=" >
    | <Dot: "." >

    | <Class: "class" >
    | <Import: "import" >
    | <If: "if" >
    | <Else: "else" >
    | <While: "while" >
    | <TypeInt: "int" >
    | <TypeBoolean: "boolean" >
    | <TypeString: "String" >
    | <Extends: "extends" >
    | <Public: "public" >
    | <Static: "static" >
    | <Void: "void" >
    | <Main: "main" >
    | <Return: "return" >
    | <Length: "length" >
    | <True: "true" >
    | <False: "false" >
    | <This: "this" >
    | <New: "new" >

    | <AndOp: "&&" >
    | <LessThanOp: "<" >
    | <AddOp: "+" >
    | <SubOp: "-" >
    | <MultOp: "*" >
    | <NotOp: "!" >
    | <Print: "System.out.println">

    | <Identifier: <Letter> (<Letter> | <Digit> | "_" )* >
    | <Letter: (<LowerCase> | <UpperCase>) >
    | <LowerCase: ["a"-"z"] >
    | <UpperCase: ["A"-"Z"] >
}

SimpleNode Program(): {} {
    (ImportDeclaration())*
    ClassDeclaration()
    <EOF>
    { return jjtThis; }
}

void ImportDeclaration(): { Token t_name; } {
    <Import> t_name = <Identifier> { jjtThis.name = t_name.image; } (<Dot> <Identifier>)* <Semicolon>
}

void ClassDeclaration(): { Token t_name; } {
    <Class> t_name = <Identifier> { jjtThis.name = t_name.image; } [ClassInheritance()]
    <OpenBlock>
        (VarDeclaration())*
        (MethodDeclaration())*
    <CloseBlock>
}

void ClassInheritance(): { Token t_name; } {
    <Extends> t_name = <Identifier> { jjtThis.name = t_name.image; }
}

void VarDeclaration(): { Token t_name; } {
    Type() t_name = <Identifier> { jjtThis.identifier = t_name.image; } <Semicolon>
}

void MethodDeclaration(): { Token t_name; } {
    <Public>
    (
    Type() t_name = <Identifier> { jjtThis.identifier = t_name.image; }
    <OpenParenthesis>
        Parameters()
    <CloseParenthesis>
    <OpenBlock>
        (LOOKAHEAD(2) VarDeclaration() | Statement())* // Allowed for now
        Return()
    <CloseBlock>
    |
    <Static> <Void> <Main> <OpenParenthesis> <TypeString> <OpenArray> <CloseArray>
    <Identifier> <CloseParenthesis> <OpenBlock>
        (LOOKAHEAD(3) VarDeclaration() | Statement())* // Allowed for now
    <CloseBlock>
    )
}

void Parameters(): {} {
    [Type() <Identifier> (<Comma> Type()  <Identifier>)*]
}

void Type(): { Token t_type; } {
    ( (t_type = <TypeInt> [<OpenArray> <CloseArray>])
    | t_type = <TypeBoolean>
    | t_type = <Identifier>
    ) { jjtThis.type = t_type.image; }
}

void Statement() #void: {} {
    (<OpenBlock> (Statement())* <CloseBlock> )
    | (<If> <OpenParenthesis> Expression() <CloseParenthesis> Statement() <Else> Statement()) #IfStatement
    | (<While> <OpenParenthesis> Expression() <CloseParenthesis> Statement()) #WhileStatement
    | (<Print> <OpenParenthesis> Expression() <CloseParenthesis> <Semicolon> ) #PrintStatement
    | (Expression() [Assignment()] <Semicolon>) #OtherStatement
}

void Assignment(): {} {
    <Equals> Expression()
}


void Return(): {} {
    <Return> Expression() <Semicolon>
}

/*
void Expression() #void: {} {
    (Expression() (<AndOp> | <LessThanOp> | <AddOp> | <SubOp> | <MultOp> ) Expression())
    | (Expression() <OpenArray> Expression() <CloseArray>)
    | (Expression() <Dot> <Length>)
    | (Expression() <Dot> <Identifier> <OpenParenthesis> [Expression() (<Comma> Expression())*] <CloseParenthesis> )
    | <IntegerLiteral>
    | <True>
    | <False>
    | <Identifier>
    | <This>
    | (<New> <TypeInt> <OpenArray> Expression() <CloseArray>)
    | (<New> <Identifier> <OpenParenthesis> <CloseParenthesis>)
    | (<NotOp> Expression())
    | (<OpenParenthesis> Expression() <CloseParenthesis>)
}
*/

void Expression() #void: {} {
    And()
}

void And() #void: {} {
    LessThan() (<AndOp> #AndExpression LessThan() )*
}

void LessThan() #void: {} {
    Add() (<LessThanOp> #LessThanExpression Add() )*
}

void Add() #void: {} {
    Sub() (<AddOp> #AddExpression Sub() )*
}

void Sub() #void: {} {
    Mult() (<SubOp> #SubExpression Mult() )*
}

void Mult() #void: {} {
    Not() (<MultOp> #MultExpression Not() )*
}

void Not() #void: {} {
    Dot() (<NotOp> #NotExpression Dot() )*
}

void Dot() #void: {} {
    Array() (DotStatement() #DotExpression Array() )*
}

void Array() #void: {} {
    Terminal() (<OpenArray> Expression() <CloseArray> #ArrayExpression Terminal() )*
}

void DotStatement() #void: {} {
    <Length> #Length
    | (LOOKAHEAD(2) <Identifier> <OpenParenthesis> [Expression() (<Comma> Expression())*] <CloseParenthesis> )* #CallExpression
}

void Terminal() #void: { Token t_value; } {
    ( t_value = <IntegerLiteral> { jjtThis.value = t_value; } ) #IntegerLiteral
    | ( t_value = <True> { jjtThis.value = t_value; } ) #True
    | ( t_value = <False> { jjtThis.value = t_value; } ) #False
    | ( t_value = <Identifier> { jjtThis.value = t_value; } ) #Identifier
    | ( t_value = <This> { jjtThis.value = t_value; } ) #This
    | (<OpenParenthesis> Expression() <CloseParenthesis> ) #ParenthesisExpression
    | New()
}

void New() #void: { Token t_type; } {
    <New> (
      ( t_type = <TypeInt> { jjtThis.type = t_type.image + " array"; } <OpenArray> Expression() <CloseArray> ) #NewIntArray
    | ( t_type = <Identifier> { jjtThis.type = t_type.image; } <OpenParenthesis> <CloseParenthesis> ) #NewClass
    )
}